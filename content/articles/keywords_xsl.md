Title: How To Create Keywords Metadata From Index Terms
Category: XML
Slug: Create-Keywords-From-Index-Terms
Date: 2014-Oct-15
Status: Draft
Tags: how-to, xslt
Summary: How to harvest index terms in DocBook to create keywords for html.

In an HTML page, the keywords can be listed in the metadata. An example might look like this
    
    :::html
    <meta name="keywords" content="DocBook, XML, XSLT, index terms" />


At one time, those words may have helped search engines find the page. However, it doesn't work that way anymore. For the past several years, most search engines don't use the metadata and most people never use them. In some situations they can still be useful, say if you are generating pages for a corporation using a Google Search Appliance that has been explicitly configured to include the keywords meta tag.

This article shows how you can harvest the primary index terms in your DocBook document and use them as keyword metadata in the HTML generated by the DocBook XSL stylesheets.

We start by adding a stylesheet to our DocBook customization layer.

    :::xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

The template is named `keywordset` and we define a variable `section_level` that describes the depth of the current section.

    :::xml
        <xsl:template name="keywordset">
            <xsl:variable name="section_level">
            <xsl:number value="count(ancestor-or-self::d:section)" />
            </xsl:variable>

if we are not on a part or book, and we have indexterms, create a new variable called `indexterms` 

* If we're on a zero-level section, do nothing.
* If we're not at the bottom of the tree (that is, the current section level is less than the level we are chunking to), get all index primary terms that are direct children and all index primary terms that are children of non-section elements (for example, index terms inside itemized lists).

Note: index terms that are children of subsections are handled recursively.
            
    :::xml
    <xsl:if test="not(self::part) and not(self::book) and .//d:indexterm">
        <xsl:variable name="indexterms">
            <xsl:choose>
            <xsl:when test="$section_level = 0" />
            <xsl:when test="$section_level &lt; $chunk.section.depth">
                <xsl:copy-of select="./d:indexterm/d:primary|./*[not(self::d:section)]//d:indexterm/d:primary" />
            </xsl:when>

Otherwise, we are in a section at a depth greater than or equal to the chunking depth. So get all of the descendant primary index terms.

    :::xml
          <xsl:otherwise>
            <xsl:copy-of select=".//d:indexterm/d:primary" />
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

So now we have a tree of all the index terms that are germane to the current chunked section. Of course it's likely we have duplicate terms, so lets get all the terms that are unique and put them into the variable `indexterms-unique`. The following technique is one of many recipes that you might find useful in [XSLT CookBook](http://shop.oreilly.com/product/9780596009748.do).

Use `xsl:for-each` to loop through the primary terms we've just gathered, and filter them so that any that are in the unique list already are skipped (they will match some *preceding* sibling). 

Then use `normalize-space` to get the string value of the element, and append a comman (`,`) if this isn't the last of the list.

    :::xml
      <xsl:variable name="indexterms-unique">
        <xsl:for-each select="exsl:node-set($indexterms)/*[not(. = preceding-sibling::*)]">
          <xsl:value-of select="normalize-space(.)" />
          <xsl:if test="not(position() =  last())">,</xsl:if>
        </xsl:for-each>
      </xsl:variable>

Finally, insert the unique, comma-separated strings into the `meta` tag

      :::xml
      <meta name="keywords">
      <xsl:attribute name="content">
        <xsl:value-of select="$indexterms-unique" />
      </xsl:attribute>
    </meta>
    </xsl:if>
    </xsl:template>
    </xsl:stylesheet>

While keyword metadata isn't useful for general search engines, you still run into situations where it is used. Harvesting index primary terms to use as keywords populate that metadata with exactly what the information needed.